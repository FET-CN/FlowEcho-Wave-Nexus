---
date: 2025-6-1 13:18:21
update: 2025-6-1 13:18:21
title: \[88掌控日文字稿\]简析掌控板 3.0 屏幕技术更新：从framebuf到LVGL
authors:
    - Frez79
---
# \[88掌控日文字稿\]简析掌控板 3.0 屏幕技术更新：从framebuf到LVGL

> PPT：<https://ouyhq.lanzoum.com/iQ4i22xqm72d>         密码:dyoh
> 本文字稿 以 CC BY-NC-SA 4.0 协议贡献 署名为Frez79(欧阳泓骞)

# 开场白

ok各位好 我是欧阳泓骞 今天让我们简单地聊聊掌控板屏幕软件部分

<!-- more -->

# 引入

众所周知啊 掌控板 v2用的是单色OLED显示屏 分辨率128x64

通过阅览代码 *(亮出mpython.py)* 可知掌控板上搭载的驱动类 *(聚焦至继承类部分)* 继承了framebuf

# 何为framebuf?

framebuf是一个提供通用帧缓冲区的模块 *(展示<https://docs.micropython.org/en/v1.12/library/framebuf.html> 并聚焦展示翻译动效)*
它将整个屏幕的内容存储于一个位于RAM的字节数组中.

> 右下小字：`何为帧缓冲区：即屏幕画面的草稿纸 程序先在这层草稿纸上作画 作画完毕后再显示出来`

你可以在这层帧缓冲区上随意作画 *(聚焦展示翻译动效)* 
我们使用掌控板 v2时 点亮像素 绘制线条 显示矩形 展示文本都离不开它(聚焦 依次展示翻译动效)

这样看来 掌控板 v2的设计还挺不错

## 衔接

但是呢 掌控板 v3发布了！*(掌控板v3图片展示)*

奇怪的是 v3没有沿用framebuf 而是选用LGVL为掌控板 v3的图形处理方案
# LGVL!

LVGL呢 是一款轻量、免费、开源的嵌入式多功能图形库 可为任何 MCU、MPU 和各类显示器绘制漂亮的 UI
> MCU、MPU:即`Microcontroller Unit`/`Micro Processor Unit`(单片机/微处理器)

### 简析优势

它相比fbuf 具有极大的优势

就例如说 它提供的是对象化UI组件：
- 每次绘制只用管理每个对象的位置 例如文字在x0y16 这个按钮在x16y32
	- 每次刷新时 你不用手动完成繁琐的UI绘制 只需要一行就可以快速解决
它提供层级化对象管理：
- 每次绘制通知 不用考虑通知与主窗口间的绘制顺序 指定层级就可以轻松解决
它提供丰富的UI组件：
- 如窗口/画布/文本框/按钮/消息框等 且美观实用
它支持增量刷新：
- 每次刷新不会无脑的刷新整个屏幕(参考v2) 而是有目的的去刷新变动的部分
- 降低屏幕延迟
> v2中 **emofalling**实现了ssd1106的分页刷新 支持 TODO:填充此处详细信息....

可能这些功能大家听起来没什么概念 现在 让我们来分点解析一下这些特性
## 分点详解

### 对象化UI组件
#### 抨击fbuf
我们先从这个对象化UI组件讲起吧
我们先来看看在fbuf 中 我们是如何存储屏幕内容的

这里由于篇幅有限 我们就不实际样式这段代码了 让我们来模拟运行看看

首先 我们执行初始化/清屏 *(执行前4line)*

我们可以看到 buffer成为了一个占用1kb的字节数组

接下来 我们在x0 y0处绘制文字 Hello World *(展示)*
可以看到 字节数组的前一部分出现了改变 但是总量还是1kb

实际上 在字节数组初始化完成的那一刻 总量就已经固定 哪怕你再怎么操作也无济于事
*(不断显示各类绘制代码 此时fbuf详细内容隐藏 表示总量的文字放大)*

虽然1kb看起来很小 但如果我们把这个方案运用到v3上 缓冲区大小就是 长乘以宽乘以4个颜色通道ARGB

即320乘以170乘以4
这里注明一下 我们的分辨率数据最开始给的是320乘以172

也就是212.5kb 要知道 掌控板v3的SRAM也只有512kb 更何况这还没有计入固件本身运行时所占的RAM

这么一来 fbuf原先依赖2.0屏幕数据量小所得的优势在掌控板v3上肯定是行不通了

#### LVGL

而LVGL 提供的是对象化UI组件 也就是说 它只存储这些组件的信息 而不会具体存储它的样貌/样式 自然而然 空间就小很多了

### 层级化对象管理
接下来 我们再来说说 LVGL 的层级化对象管理
它其实就是我们经常谈论的：图层(layers)

但是在LVGL中 图层也变得多样化了起来 Layers在LVGL中一共有这三种解释：

分别是：
•Order of Creation（图层顺序）
•Draw Layers（绘制图层）
•Screen Layers（屏幕图层）
由于翻译原因 他们听起来有些怪异 但其实他们都对应了三个不同环节中的先后顺序调节

#### 图层顺序
其中 图层顺序在开发中最为常见

我们主要看Order of Creation 图层顺序

默认情况下，LVGL会将新添加的控件绘制在旧的控件之上 和framebuf绘制的逻辑相同

但它与fbuf绘制逻辑不同的是 我们可以改变控件的顺序

LVGL提供了多样化的API用于处理先后顺序 其中对于父子组件的绑定的顺序处理也有涉及 大大便利了开发者的编码过程

### 丰富的UI组件

而关于UI组件 那更是多种多样 LVGL的每个组件都有详细的文档/说明/示例

并且LVGL还开放了第三方库 甚至可以 集成ffmpeg进行视频播放/展示二维码

### 对象刷新

关于对象刷新 我们拿之前的`Hello World`举例吧

如图 这段代码中的最后一行 便是负责刷新的部分 它的主要逻辑如右图

我们主要看有关 渲染管线的部分

从中我们可以看到 在渲染管线中 LVGL先是收集这次渲染与上次不同的零碎区域 即脏区域

然后 LVGL会把所有的脏区域叠加起来 形成一个需要重新渲染的区域

接着 LVGL将会按照我们上文提到的 图层顺序 进行渲染/处理 形成最终画面之后 调用屏幕驱动 显示最终画面


这个渲染流程有一个特点：它是选择性渲染 也就是说 它不会无脑的把每个对象都重新计算一遍 而是合理地以一种最小化计算占用资源的形式重新渲染

这样一来 刷新屏幕这一操作就大大地减少了数据运算量 加快了刷新速度

## 易用性

除此之外 盛思针对LVGL特地再封装了一个库 相比于LVGL更加复杂高级的响应式UI的 怎么做

盛思封装的lv_gui库通过声明式UI 的 做什么 大大简化了UI绘制过程中 在开发者层面的繁琐步骤

使得掌控板3.0上的LVGL变得更加易用


# 总结

综上所述

盛思依托LVGL的 高性能/多组件/少占用 为掌控板集成了一套近乎完美的UI
而在这之上 又通过 lv_gui 模块 和 图形化适配 为心有余而力不足的开发者 牵线搭桥
可以说是相当优秀的设计了

我的分享到此结束 接下来有请Can1425为我们带来有关的LVGL实战演练